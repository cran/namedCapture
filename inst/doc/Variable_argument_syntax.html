<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Toby Dylan Hocking" />

<meta name="date" content="2019-02-25" />

<title>Variable argument syntax</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' || rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Variable argument syntax</h1>
<h4 class="author"><em>Toby Dylan Hocking</em></h4>
<h4 class="date"><em>2019-02-25</em></h4>



<p>This is the second vignette – we assume you have already read the “three argument syntax” vignette which covers the most basic <code>namedCapture</code> functions, <code>str_match_named</code> and <code>str_match_all_named</code>. Here we introduce the syntax used in the <code>namedCapture::*_variable</code> functions, which is motivated by the desire to avoid repetitive/boilerplate code. In the previous vignette we used the following code to extract the first match from each subject,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">subject.vec &lt;-<span class="st"> </span><span class="kw">c</span>(
  <span class="st">&quot;chr10:213,054,000-213,055,000&quot;</span>,
  <span class="st">&quot;chrM:111,000&quot;</span>,
  <span class="st">&quot;this will not match&quot;</span>,
  <span class="ot">NA</span>, <span class="co"># neither will this.</span>
  <span class="st">&quot;chr1:110-111 chr2:220-222&quot;</span>) <span class="co"># two possible matches.</span>
chr.pos.pattern &lt;-<span class="st"> </span><span class="kw">paste0</span>(
  <span class="st">&quot;(?P&lt;chrom&gt;chr.*?)&quot;</span>,
  <span class="st">&quot;:&quot;</span>,
  <span class="st">&quot;(?P&lt;chromStart&gt;[0-9,]+)&quot;</span>,
  <span class="st">&quot;(?:&quot;</span>,
    <span class="st">&quot;-&quot;</span>,
    <span class="st">&quot;(?P&lt;chromEnd&gt;[0-9,]*)&quot;</span>,
  <span class="st">&quot;)?&quot;</span>)
namedCapture::<span class="kw">str_match_named</span>(subject.vec, chr.pos.pattern)
<span class="co">#&gt;      chrom   chromStart    chromEnd     </span>
<span class="co">#&gt; [1,] &quot;chr10&quot; &quot;213,054,000&quot; &quot;213,055,000&quot;</span>
<span class="co">#&gt; [2,] &quot;chrM&quot;  &quot;111,000&quot;     &quot;&quot;           </span>
<span class="co">#&gt; [3,] NA      NA            NA           </span>
<span class="co">#&gt; [4,] NA      NA            NA           </span>
<span class="co">#&gt; [5,] &quot;chr1&quot;  &quot;110&quot;         &quot;111&quot;</span></code></pre></div>
<p>Note that the pattern above is defined using the <code>paste0</code> boilerplate, which is used to break the pattern over several lines for clarity. Using the variable argument syntax, we can omit <code>paste0</code>, and simply supply the pattern strings to <code>str_match_variable</code> directly,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">namedCapture::<span class="kw">str_match_variable</span>(
  subject.vec, 
  <span class="st">&quot;(?P&lt;chrom&gt;chr.*?)&quot;</span>,
  <span class="st">&quot;:&quot;</span>,
  <span class="st">&quot;(?P&lt;chromStart&gt;[0-9,]+)&quot;</span>,
  <span class="st">&quot;(?:&quot;</span>,
    <span class="st">&quot;-&quot;</span>,
    <span class="st">&quot;(?P&lt;chromEnd&gt;[0-9,]+)&quot;</span>,
  <span class="st">&quot;)?&quot;</span>)
<span class="co">#&gt;      chrom   chromStart    chromEnd     </span>
<span class="co">#&gt; [1,] &quot;chr10&quot; &quot;213,054,000&quot; &quot;213,055,000&quot;</span>
<span class="co">#&gt; [2,] &quot;chrM&quot;  &quot;111,000&quot;     &quot;&quot;           </span>
<span class="co">#&gt; [3,] NA      NA            NA           </span>
<span class="co">#&gt; [4,] NA      NA            NA           </span>
<span class="co">#&gt; [5,] &quot;chr1&quot;  &quot;110&quot;         &quot;111&quot;</span></code></pre></div>
<p>We can further simplify by removing the named capture groups from the strings, and adding names to the corresponding arguments. For <code>name1=&quot;pattern1&quot;</code>, <code>namedCapture</code> internally generates/uses the regex <code>(?P&lt;name1&gt;pattern1)</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">namedCapture::<span class="kw">str_match_variable</span>(
  subject.vec, 
  <span class="dt">chrom=</span><span class="st">&quot;chr.*?&quot;</span>,
  <span class="st">&quot;:&quot;</span>,
  <span class="dt">chromStart=</span><span class="st">&quot;[0-9,]+&quot;</span>,
  <span class="st">&quot;(?:&quot;</span>,
    <span class="st">&quot;-&quot;</span>,
    <span class="dt">chromEnd=</span><span class="st">&quot;[0-9,]+&quot;</span>,
  <span class="st">&quot;)?&quot;</span>)
<span class="co">#&gt;      chrom   chromStart    chromEnd     </span>
<span class="co">#&gt; [1,] &quot;chr10&quot; &quot;213,054,000&quot; &quot;213,055,000&quot;</span>
<span class="co">#&gt; [2,] &quot;chrM&quot;  &quot;111,000&quot;     &quot;&quot;           </span>
<span class="co">#&gt; [3,] NA      NA            NA           </span>
<span class="co">#&gt; [4,] NA      NA            NA           </span>
<span class="co">#&gt; [5,] &quot;chr1&quot;  &quot;110&quot;         &quot;111&quot;</span></code></pre></div>
<p>We can add type conversion functions on the same line as the definition of the named group:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">keep.digits &lt;-<span class="st"> </span>function(x)<span class="kw">as.integer</span>(<span class="kw">gsub</span>(<span class="st">&quot;[^0-9]&quot;</span>, <span class="st">&quot;&quot;</span>, x))
namedCapture::<span class="kw">str_match_variable</span>(
  subject.vec, 
  <span class="dt">chrom=</span><span class="st">&quot;chr.*?&quot;</span>,
  <span class="st">&quot;:&quot;</span>,
  <span class="dt">chromStart=</span><span class="st">&quot;[0-9,]+&quot;</span>, keep.digits,
  <span class="st">&quot;(?:&quot;</span>,
    <span class="st">&quot;-&quot;</span>,
    <span class="dt">chromEnd=</span><span class="st">&quot;[0-9,]+&quot;</span>, keep.digits,
  <span class="st">&quot;)?&quot;</span>)
<span class="co">#&gt;   chrom chromStart  chromEnd</span>
<span class="co">#&gt; 1 chr10  213054000 213055000</span>
<span class="co">#&gt; 2  chrM     111000        NA</span>
<span class="co">#&gt; 3  &lt;NA&gt;         NA        NA</span>
<span class="co">#&gt; 4  &lt;NA&gt;         NA        NA</span>
<span class="co">#&gt; 5  chr1        110       111</span></code></pre></div>
<p>Note the repetition in the chromStart/End lines – the same pattern and type conversion function is used for each group. This repetition can be avoided by creating and using a sub-pattern list variable,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pos.pattern &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="st">&quot;[0-9,]+&quot;</span>, keep.digits)
namedCapture::<span class="kw">str_match_variable</span>(
  subject.vec, 
  <span class="dt">chrom=</span><span class="st">&quot;chr.*?&quot;</span>,
  <span class="st">&quot;:&quot;</span>,
  <span class="dt">chromStart=</span>pos.pattern,
  <span class="st">&quot;(?:&quot;</span>,
    <span class="st">&quot;-&quot;</span>,
    <span class="dt">chromEnd=</span>pos.pattern,
  <span class="st">&quot;)?&quot;</span>)
<span class="co">#&gt;   chrom chromStart  chromEnd</span>
<span class="co">#&gt; 1 chr10  213054000 213055000</span>
<span class="co">#&gt; 2  chrM     111000        NA</span>
<span class="co">#&gt; 3  &lt;NA&gt;         NA        NA</span>
<span class="co">#&gt; 4  &lt;NA&gt;         NA        NA</span>
<span class="co">#&gt; 5  chr1        110       111</span></code></pre></div>
<p>Finally, the non-capturing group can be replaced by an un-named list:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pos.pattern &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="st">&quot;[0-9,]+&quot;</span>, keep.digits)
namedCapture::<span class="kw">str_match_variable</span>(
  subject.vec, 
  <span class="dt">chrom=</span><span class="st">&quot;chr.*?&quot;</span>,
  <span class="st">&quot;:&quot;</span>,
  <span class="dt">chromStart=</span>pos.pattern,
  <span class="kw">list</span>(
    <span class="st">&quot;-&quot;</span>,
    <span class="dt">chromEnd=</span>pos.pattern
  ), <span class="st">&quot;?&quot;</span>)
<span class="co">#&gt;   chrom chromStart  chromEnd</span>
<span class="co">#&gt; 1 chr10  213054000 213055000</span>
<span class="co">#&gt; 2  chrM     111000        NA</span>
<span class="co">#&gt; 3  &lt;NA&gt;         NA        NA</span>
<span class="co">#&gt; 4  &lt;NA&gt;         NA        NA</span>
<span class="co">#&gt; 5  chr1        110       111</span></code></pre></div>
<p>In summary, the <code>str_match_variable</code> function takes a variable number of arguments, and allows for a shorter, less repetitive, and thus more user-friendly syntax:</p>
<ul>
<li>The first argument is the subject character vector.</li>
<li>The other arguments specify the pattern, via character strings, functions, and/or lists.</li>
<li>If a pattern (character/list) is named, we use the argument name in R for the capture group name in the regex.</li>
<li>Each function is used to convert the text extracted by the previous named pattern argument. (type conversion can only be used with named R arguments, NOT with explicitly specified named groups in regex strings)</li>
<li>Lists may be used to avoid repetition in the definition of the pattern and type conversion functions.</li>
<li>Each list generates a group in the regex (named list =&gt; named capture group, un-named list =&gt; non-capturing group).</li>
<li>All patterns are pasted together in the order that they appear in the argument list.</li>
</ul>
<div id="extract-all-patterns-from-a-file" class="section level2">
<h2>Extract all patterns from a file</h2>
<p>The variable argument syntax can also be used with <code>str_match_all_variable</code>, which is for the common case of extracting each match from a multi-line text file. In this section we demonstrate how to use <code>str_match_all_variable</code> to extract data.frames from a loosely structured text file.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">trackDb.txt.gz &lt;-<span class="st"> </span><span class="kw">system.file</span>(
  <span class="st">&quot;extdata&quot;</span>, <span class="st">&quot;trackDb.txt.gz&quot;</span>, <span class="dt">package=</span><span class="st">&quot;namedCapture&quot;</span>)
trackDb.vec &lt;-<span class="st"> </span><span class="kw">readLines</span>(trackDb.txt.gz)</code></pre></div>
<p>Some representative lines from that file are shown below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(trackDb.vec[<span class="dv">78</span>:<span class="dv">107</span>], <span class="dt">sep=</span><span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
<span class="co">#&gt; track peaks_summary</span>
<span class="co">#&gt; type bigBed 5</span>
<span class="co">#&gt; shortLabel _model_peaks_summary</span>
<span class="co">#&gt; longLabel Regions with a peak in at least one sample</span>
<span class="co">#&gt; visibility pack</span>
<span class="co">#&gt; itemRgb off</span>
<span class="co">#&gt; spectrum on</span>
<span class="co">#&gt; bigDataUrl http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/peaks_summary.bigBed</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt;  track bcell_McGill0091</span>
<span class="co">#&gt;  parent bcell</span>
<span class="co">#&gt;  container multiWig</span>
<span class="co">#&gt;  type bigWig</span>
<span class="co">#&gt;  shortLabel bcell_McGill0091</span>
<span class="co">#&gt;  longLabel bcell | McGill0091</span>
<span class="co">#&gt;  graphType points</span>
<span class="co">#&gt;  aggregate transparentOverlay</span>
<span class="co">#&gt;  showSubtrackColorOnUi on</span>
<span class="co">#&gt;  maxHeightPixels 25:12:8</span>
<span class="co">#&gt;  visibility full</span>
<span class="co">#&gt;  autoScale on</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;   track bcell_McGill0091Coverage</span>
<span class="co">#&gt;   bigDataUrl http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/samples/bcell/McGill0091/coverage.bigWig</span>
<span class="co">#&gt;   shortLabel bcell_McGill0091Coverage</span>
<span class="co">#&gt;   longLabel bcell | McGill0091 | Coverage</span>
<span class="co">#&gt;   parent bcell_McGill0091</span>
<span class="co">#&gt;   type bigWig</span>
<span class="co">#&gt;   color 141,211,199</span></code></pre></div>
<p>Each block of text begins with “track” and includes several lines of data before the block ends with two consecutive newlines. That pattern is coded below using a regex:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fields.df &lt;-<span class="st"> </span>namedCapture::<span class="kw">str_match_all_variable</span>(
  trackDb.vec,
  <span class="st">&quot;track &quot;</span>,
  <span class="dt">name=</span><span class="st">&quot;</span><span class="ch">\\</span><span class="st">S+&quot;</span>,
  <span class="dt">fields=</span><span class="st">&quot;(?:</span><span class="ch">\n</span><span class="st">[^</span><span class="ch">\n</span><span class="st">]+)*&quot;</span>,
  <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</code></pre></div>
<p>Note that this function assumes that its first argument is a character vector with one element for each line in a file. Therefore the result contains no information about which subject element each match comes from (to get that, use <code>str_match_all_named</code>). The code above creates a data frame with one row for each track block, with rownames given by the track line (because of the capture group named name), and one fields column which is a string with the rest of the data in that block.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(fields.df)
<span class="co">#&gt;                        fields                                                                                                      </span>
<span class="co">#&gt; bcell                  &quot;\nsuperTrack on show\nshortLabel bcell\nlongLabel bcell ChIP-seq samples&quot;                                  </span>
<span class="co">#&gt; kidneyCancer           &quot;\nsuperTrack on show\nshortLabel kidneyCancer\nlongLabel kidneyCancer ChIP-seq samples&quot;                    </span>
<span class="co">#&gt; kidney                 &quot;\nsuperTrack on show\nshortLabel kidney\nlongLabel kidney ChIP-seq samples&quot;                                </span>
<span class="co">#&gt; leukemiaCD19CD10BCells &quot;\nsuperTrack on show\nshortLabel leukemiaCD19CD10BCells\nlongLabel leukemiaCD19CD10BCells ChIP-seq samples&quot;</span>
<span class="co">#&gt; monocyte               &quot;\nsuperTrack on show\nshortLabel monocyte\nlongLabel monocyte ChIP-seq samples&quot;                            </span>
<span class="co">#&gt; skeletalMuscleCtrl     &quot;\nsuperTrack on show\nshortLabel skeletalMuscleCtrl\nlongLabel skeletalMuscleCtrl ChIP-seq samples&quot;</span></code></pre></div>
<p>Each block has a variable number of lines/fields. Each line starts with a field name, followed by a space, followed by the field value. That regex is coded below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fields.list &lt;-<span class="st"> </span>namedCapture::<span class="kw">str_match_all_named</span>(
  fields.df[, <span class="st">&quot;fields&quot;</span>], <span class="kw">paste0</span>(
    <span class="st">&quot;</span><span class="ch">\\</span><span class="st">s+&quot;</span>,
    <span class="st">&quot;(?P&lt;name&gt;.*?)&quot;</span>,
    <span class="st">&quot; &quot;</span>,
    <span class="st">&quot;(?P&lt;value&gt;[^</span><span class="ch">\n</span><span class="st">]+)&quot;</span>))</code></pre></div>
<p>Note that we used <code>str_match_all_named</code> which outputs a list in order to keep info about which match came from which subject. The result is a list of data frames.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fields.list[<span class="dv">12</span>:<span class="dv">14</span>]
<span class="co">#&gt; $peaks_summary</span>
<span class="co">#&gt;            value                                                                  </span>
<span class="co">#&gt; type       &quot;bigBed 5&quot;                                                             </span>
<span class="co">#&gt; shortLabel &quot;_model_peaks_summary&quot;                                                 </span>
<span class="co">#&gt; longLabel  &quot;Regions with a peak in at least one sample&quot;                           </span>
<span class="co">#&gt; visibility &quot;pack&quot;                                                                 </span>
<span class="co">#&gt; itemRgb    &quot;off&quot;                                                                  </span>
<span class="co">#&gt; spectrum   &quot;on&quot;                                                                   </span>
<span class="co">#&gt; bigDataUrl &quot;http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/peaks_summary.bigBed&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $bcell_McGill0091</span>
<span class="co">#&gt;                       value               </span>
<span class="co">#&gt; parent                &quot;bcell&quot;             </span>
<span class="co">#&gt; container             &quot;multiWig&quot;          </span>
<span class="co">#&gt; type                  &quot;bigWig&quot;            </span>
<span class="co">#&gt; shortLabel            &quot;bcell_McGill0091&quot;  </span>
<span class="co">#&gt; longLabel             &quot;bcell | McGill0091&quot;</span>
<span class="co">#&gt; graphType             &quot;points&quot;            </span>
<span class="co">#&gt; aggregate             &quot;transparentOverlay&quot;</span>
<span class="co">#&gt; showSubtrackColorOnUi &quot;on&quot;                </span>
<span class="co">#&gt; maxHeightPixels       &quot;25:12:8&quot;           </span>
<span class="co">#&gt; visibility            &quot;full&quot;              </span>
<span class="co">#&gt; autoScale             &quot;on&quot;                </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $bcell_McGill0091Coverage</span>
<span class="co">#&gt;            value                                                                                      </span>
<span class="co">#&gt; bigDataUrl &quot;http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/samples/bcell/McGill0091/coverage.bigWig&quot;</span>
<span class="co">#&gt; shortLabel &quot;bcell_McGill0091Coverage&quot;                                                                 </span>
<span class="co">#&gt; longLabel  &quot;bcell | McGill0091 | Coverage&quot;                                                            </span>
<span class="co">#&gt; parent     &quot;bcell_McGill0091&quot;                                                                         </span>
<span class="co">#&gt; type       &quot;bigWig&quot;                                                                                   </span>
<span class="co">#&gt; color      &quot;141,211,199&quot;</span></code></pre></div>
<p>There is a list element for each block, named by track. Each list element is a data frame with one row per field defined in that block (rownames are field names). The names/rownames make it easy to write R code that selects individual elements by name, e.g.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fields.list$bcell_McGill0091Coverage[<span class="st">&quot;bigDataUrl&quot;</span>,]
<span class="co">#&gt; [1] &quot;http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/samples/bcell/McGill0091/coverage.bigWig&quot;</span>
fields.list$monocyte_McGill0001Peaks[<span class="st">&quot;color&quot;</span>,]
<span class="co">#&gt; [1] &quot;0,0,0&quot;</span>
has.bigDataUrl &lt;-<span class="st"> </span><span class="kw">sapply</span>(fields.list, function(m)<span class="st">&quot;bigDataUrl&quot;</span> %in%<span class="st"> </span><span class="kw">rownames</span>(m))
bigDataUrl.list &lt;-<span class="st"> </span>fields.list[has.bigDataUrl]
<span class="kw">length</span>(bigDataUrl.list)
<span class="co">#&gt; [1] 78</span>
<span class="kw">length</span>(fields.list)
<span class="co">#&gt; [1] 123</span></code></pre></div>
<p>So there are 78 tracks which define the bigDataUrl field, out of 123 total tracks.</p>
<p>In the example above we extracted all fields from all tracks (using two regexes, one for the track, one for the field). In the example below we extract only the bigDataUrl field for each track, and split sample names into separate columns (using a single regex for the track). It also demonstrates how to use nested named capture groups (via named lists which contain named regex strings).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">name.pattern &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="dt">cellType=</span><span class="st">&quot;.*?&quot;</span>,
  <span class="st">&quot;_&quot;</span>,
  <span class="dt">sampleName=</span><span class="kw">list</span>(
    <span class="st">&quot;McGill&quot;</span>,
    <span class="dt">sampleID=</span><span class="st">&quot;[0-9]+&quot;</span>, as.integer),
  <span class="dt">dataType=</span><span class="st">&quot;Coverage|Peaks&quot;</span>,
  <span class="st">&quot;|&quot;</span>,
  <span class="st">&quot;[^</span><span class="ch">\n</span><span class="st">]+&quot;</span>)
match.df &lt;-<span class="st"> </span>namedCapture::<span class="kw">str_match_all_variable</span>(
  trackDb.vec,
  <span class="st">&quot;track &quot;</span>,
  <span class="dt">name=</span>name.pattern,
  <span class="st">&quot;(?:</span><span class="ch">\n</span><span class="st">[^</span><span class="ch">\n</span><span class="st">]+)*&quot;</span>,
  <span class="st">&quot;</span><span class="ch">\\</span><span class="st">s+bigDataUrl &quot;</span>,
  <span class="dt">bigDataUrl=</span><span class="st">&quot;[^</span><span class="ch">\n</span><span class="st">]+&quot;</span>)
<span class="kw">head</span>(match.df)
<span class="co">#&gt;                          cellType sampleName sampleID dataType</span>
<span class="co">#&gt; all_labels                                         NA         </span>
<span class="co">#&gt; problems                                           NA         </span>
<span class="co">#&gt; jointProblems                                      NA         </span>
<span class="co">#&gt; peaks_summary                                      NA         </span>
<span class="co">#&gt; bcell_McGill0091Coverage    bcell McGill0091       91 Coverage</span>
<span class="co">#&gt; bcell_McGill0091Peaks       bcell McGill0091       91    Peaks</span>
<span class="co">#&gt;                                                                                                            bigDataUrl</span>
<span class="co">#&gt; all_labels                                         http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/all_labels.bigBed</span>
<span class="co">#&gt; problems                                             http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/problems.bigBed</span>
<span class="co">#&gt; jointProblems                                   http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/jointProblems.bigBed</span>
<span class="co">#&gt; peaks_summary                                   http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/peaks_summary.bigBed</span>
<span class="co">#&gt; bcell_McGill0091Coverage    http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/samples/bcell/McGill0091/coverage.bigWig</span>
<span class="co">#&gt; bcell_McGill0091Peaks    http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/samples/bcell/McGill0091/joint_peaks.bigWig</span></code></pre></div>
<p>Exercise for the reader: modify the above regex in order to capture three additional columns (red, green, blue) from the color field.</p>
</div>
<div id="extract-several-columns-of-a-data-frame" class="section level2">
<h2>Extract several columns of a data frame</h2>
<p>We also provide <code>namedCapture::df_match_variable</code> which extracts text from several columns of a data.frame, using a different named capture regular expression for each column.</p>
<ul>
<li>It requires a data.frame as the first argument.</li>
<li>It takes a variable number of other arguments, all of which must be named. For each other argument we call <code>str_match_variable</code> on one column of the input data.frame.</li>
<li>Each argument name specifies a column of the data.frame which will be used as the subject in <code>str_match_variable</code>.</li>
<li>Each argument value specifies a pattern to be used with <code>str_match_variable</code>, in list/character/function format as explained in the previous section.</li>
<li>The return value is a data.frame with the same number of rows as the input, but with an additional column for each named capture group. New columns are named using the convention <code>subjectColumnName.groupName</code>.</li>
<li>This is a “tidy” function that can be used in a <a href="https://r4ds.had.co.nz/pipes.html">pipe</a>. This function can greatly simplify the code required to create numeric data columns from character data columns. For example consider the following data which was output from the <a href="https://slurm.schedmd.com/sacct.html">sacct</a> program.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(sacct.df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(
  <span class="dt">Elapsed =</span> <span class="kw">c</span>(
    <span class="st">&quot;07:04:42&quot;</span>, <span class="st">&quot;07:04:42&quot;</span>, <span class="st">&quot;07:04:49&quot;</span>,
    <span class="st">&quot;00:00:00&quot;</span>, <span class="st">&quot;00:00:00&quot;</span>),
  <span class="dt">JobID=</span><span class="kw">c</span>(
    <span class="st">&quot;13937810_25&quot;</span>,
    <span class="st">&quot;13937810_25.batch&quot;</span>,
    <span class="st">&quot;13937810_25.extern&quot;</span>,
    <span class="st">&quot;14022192_[1-3]&quot;</span>,
    <span class="st">&quot;14022204_[4]&quot;</span>),
  <span class="dt">stringsAsFactors=</span><span class="ot">FALSE</span>))
<span class="co">#&gt;    Elapsed              JobID</span>
<span class="co">#&gt; 1 07:04:42        13937810_25</span>
<span class="co">#&gt; 2 07:04:42  13937810_25.batch</span>
<span class="co">#&gt; 3 07:04:49 13937810_25.extern</span>
<span class="co">#&gt; 4 00:00:00     14022192_[1-3]</span>
<span class="co">#&gt; 5 00:00:00       14022204_[4]</span></code></pre></div>
<p>Say we want to filter by the total Elapsed time (which is reported as hours:minutes:seconds), and base job id (which is the number before the underscore in the JobID column). We could start by converting those character columns to integers via:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Define some sub-patterns separately for clarity.
range.pattern &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="st">&quot;[[]&quot;</span>,
  <span class="dt">task1=</span><span class="st">&quot;[0-9]+&quot;</span>, as.integer,
  <span class="st">&quot;(?:-&quot;</span>,<span class="co">#begin optional end of range.</span>
  <span class="dt">taskN=</span><span class="st">&quot;[0-9]+&quot;</span>, as.integer,
  <span class="st">&quot;)?&quot;</span>, <span class="co">#end is optional.</span>
  <span class="st">&quot;[]]&quot;</span>)
task.pattern &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="st">&quot;(?:&quot;</span>,<span class="co">#begin alternate</span>
  <span class="dt">task=</span><span class="st">&quot;[0-9]+&quot;</span>, as.integer,
  <span class="st">&quot;|&quot;</span>,<span class="co">#either one task(above) or range(below)</span>
  range.pattern,
  <span class="st">&quot;)&quot;</span>)<span class="co">#end alternate</span>
(task.df &lt;-<span class="st"> </span>namedCapture::<span class="kw">df_match_variable</span>(
  sacct.df,
  <span class="dt">JobID=</span><span class="kw">list</span>(
    <span class="dt">job=</span><span class="st">&quot;[0-9]+&quot;</span>, as.integer,
    <span class="st">&quot;_&quot;</span>,
    task.pattern,
    <span class="st">&quot;(?:[.]&quot;</span>,
    <span class="dt">type=</span><span class="st">&quot;.*&quot;</span>,
    <span class="st">&quot;)?&quot;</span>),
  <span class="dt">Elapsed=</span><span class="kw">list</span>(
    <span class="dt">hours=</span><span class="st">&quot;[0-9]+&quot;</span>, as.integer,
    <span class="st">&quot;:&quot;</span>,
    <span class="dt">minutes=</span><span class="st">&quot;[0-9]+&quot;</span>, as.integer,
    <span class="st">&quot;:&quot;</span>,
    <span class="dt">seconds=</span><span class="st">&quot;[0-9]+&quot;</span>, as.integer)))
<span class="co">#&gt;    Elapsed              JobID JobID.job JobID.task JobID.task1 JobID.taskN</span>
<span class="co">#&gt; 1 07:04:42        13937810_25  13937810         25          NA          NA</span>
<span class="co">#&gt; 2 07:04:42  13937810_25.batch  13937810         25          NA          NA</span>
<span class="co">#&gt; 3 07:04:49 13937810_25.extern  13937810         25          NA          NA</span>
<span class="co">#&gt; 4 00:00:00     14022192_[1-3]  14022192         NA           1           3</span>
<span class="co">#&gt; 5 00:00:00       14022204_[4]  14022204         NA           4          NA</span>
<span class="co">#&gt;   JobID.type Elapsed.hours Elapsed.minutes Elapsed.seconds</span>
<span class="co">#&gt; 1                        7               4              42</span>
<span class="co">#&gt; 2      batch             7               4              42</span>
<span class="co">#&gt; 3     extern             7               4              49</span>
<span class="co">#&gt; 4                        0               0               0</span>
<span class="co">#&gt; 5                        0               0               0</span></code></pre></div>
<p>The result is another data frame with an additional column for each named capture group. Note that this also works with <code>data.table</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(data.table)
sacct.dt &lt;-<span class="st"> </span><span class="kw">data.table</span>(sacct.df)
(task.dt &lt;-<span class="st"> </span>namedCapture::<span class="kw">df_match_variable</span>(
  sacct.dt,
  <span class="dt">JobID=</span><span class="kw">list</span>(
    <span class="dt">job=</span><span class="st">&quot;[0-9]+&quot;</span>, as.integer,
    <span class="st">&quot;_&quot;</span>,
    task.pattern,
    <span class="st">&quot;(?:[.]&quot;</span>,
    <span class="dt">type=</span><span class="st">&quot;.*&quot;</span>,
    <span class="st">&quot;)?&quot;</span>),
  <span class="dt">Elapsed=</span><span class="kw">list</span>(
    <span class="dt">hours=</span><span class="st">&quot;[0-9]+&quot;</span>, as.integer,
    <span class="st">&quot;:&quot;</span>,
    <span class="dt">minutes=</span><span class="st">&quot;[0-9]+&quot;</span>, as.integer,
    <span class="st">&quot;:&quot;</span>,
    <span class="dt">seconds=</span><span class="st">&quot;[0-9]+&quot;</span>, as.integer)))
<span class="co">#&gt;     Elapsed              JobID JobID.job JobID.task JobID.task1</span>
<span class="co">#&gt; 1: 07:04:42        13937810_25  13937810         25          NA</span>
<span class="co">#&gt; 2: 07:04:42  13937810_25.batch  13937810         25          NA</span>
<span class="co">#&gt; 3: 07:04:49 13937810_25.extern  13937810         25          NA</span>
<span class="co">#&gt; 4: 00:00:00     14022192_[1-3]  14022192         NA           1</span>
<span class="co">#&gt; 5: 00:00:00       14022204_[4]  14022204         NA           4</span>
<span class="co">#&gt;    JobID.taskN JobID.type Elapsed.hours Elapsed.minutes Elapsed.seconds</span>
<span class="co">#&gt; 1:          NA                        7               4              42</span>
<span class="co">#&gt; 2:          NA      batch             7               4              42</span>
<span class="co">#&gt; 3:          NA     extern             7               4              49</span>
<span class="co">#&gt; 4:           3                        0               0               0</span>
<span class="co">#&gt; 5:          NA                        0               0               0</span></code></pre></div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

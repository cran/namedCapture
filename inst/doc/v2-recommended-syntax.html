<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Recommended variable argument syntax</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{vignette 2: recommended variable argument syntax}
-->

<h1>Recommended variable argument syntax</h1>

<p>This is the second vignette &ndash; we assume you have already read the
&ldquo;three argument syntax&rdquo; vignette which covers the most basic
<code>namedCapture</code> functions, <code>str_match_named</code> and
<code>str_match_all_named</code>. Here we introduce the syntax used in the
<code>namedCapture::*_variable</code> functions, which is motivated by the desire
to avoid repetitive/boilerplate code.</p>

<h2>Extract the first match from each subject</h2>

<p>In the previous vignette we used the following code to extract the first match from each subject,</p>

<pre><code class="r">subject.vec &lt;- c(
  &quot;chr10:213,054,000-213,055,000&quot;,
  &quot;chrM:111,000&quot;,
  &quot;this will not match&quot;,
  NA, # neither will this.
  &quot;chr1:110-111 chr2:220-222&quot;) # two possible matches.
## Single line pattern, not so easy to read.
single.line.pattern &lt;-
  &quot;(?P&lt;chrom&gt;chr.*?):(?P&lt;chromStart&gt;[0-9,]+)(?:-(?P&lt;chromEnd&gt;[0-9,]+))?&quot;
## Same pattern defined over multiple lines, easier to read.
chr.pos.pattern &lt;- paste0(
  &quot;(?P&lt;chrom&gt;chr.*?)&quot;,
  &quot;:&quot;,
  &quot;(?P&lt;chromStart&gt;[0-9,]+)&quot;,
  &quot;(?:&quot;,
    &quot;-&quot;,
    &quot;(?P&lt;chromEnd&gt;[0-9,]+)&quot;,
  &quot;)?&quot;)
identical(single.line.pattern, chr.pos.pattern)
#&gt; [1] TRUE
namedCapture::str_match_named(subject.vec, chr.pos.pattern)
#&gt;      chrom   chromStart    chromEnd     
#&gt; [1,] &quot;chr10&quot; &quot;213,054,000&quot; &quot;213,055,000&quot;
#&gt; [2,] &quot;chrM&quot;  &quot;111,000&quot;     &quot;&quot;           
#&gt; [3,] NA      NA            NA           
#&gt; [4,] NA      NA            NA           
#&gt; [5,] &quot;chr1&quot;  &quot;110&quot;         &quot;111&quot;
</code></pre>

<p>Note that the pattern above is defined using the <code>paste0</code> boilerplate, which is used to break the pattern over several lines for clarity. Using the variable argument syntax, we can omit <code>paste0</code>, and simply supply the pattern strings to <code>str_match_variable</code> directly,</p>

<pre><code class="r">namedCapture::str_match_variable(
  subject.vec, 
  &quot;(?P&lt;chrom&gt;chr.*?)&quot;,
  &quot;:&quot;,
  &quot;(?P&lt;chromStart&gt;[0-9,]+)&quot;,
  &quot;(?:&quot;,
    &quot;-&quot;,
    &quot;(?P&lt;chromEnd&gt;[0-9,]+)&quot;,
  &quot;)?&quot;)
#&gt;      chrom   chromStart    chromEnd     
#&gt; [1,] &quot;chr10&quot; &quot;213,054,000&quot; &quot;213,055,000&quot;
#&gt; [2,] &quot;chrM&quot;  &quot;111,000&quot;     &quot;&quot;           
#&gt; [3,] NA      NA            NA           
#&gt; [4,] NA      NA            NA           
#&gt; [5,] &quot;chr1&quot;  &quot;110&quot;         &quot;111&quot;
</code></pre>

<p>We can further simplify by removing the named capture groups from the strings, and adding names to the corresponding arguments. For <code>name1=&quot;pattern1&quot;</code>, <code>namedCapture</code> internally generates/uses the regex <code>(?P&lt;name1&gt;pattern1)</code>.</p>

<pre><code class="r">namedCapture::str_match_variable(
  subject.vec, 
  chrom=&quot;chr.*?&quot;,
  &quot;:&quot;,
  chromStart=&quot;[0-9,]+&quot;,
  &quot;(?:&quot;,
    &quot;-&quot;,
    chromEnd=&quot;[0-9,]+&quot;,
  &quot;)?&quot;)
#&gt;      chrom   chromStart    chromEnd     
#&gt; [1,] &quot;chr10&quot; &quot;213,054,000&quot; &quot;213,055,000&quot;
#&gt; [2,] &quot;chrM&quot;  &quot;111,000&quot;     &quot;&quot;           
#&gt; [3,] NA      NA            NA           
#&gt; [4,] NA      NA            NA           
#&gt; [5,] &quot;chr1&quot;  &quot;110&quot;         &quot;111&quot;
</code></pre>

<p>We can add type conversion functions on the same line as the definition of the named group:</p>

<pre><code class="r">keep.digits &lt;- function(x)as.integer(gsub(&quot;[^0-9]&quot;, &quot;&quot;, x))
(match.df &lt;- namedCapture::str_match_variable(
  subject.vec, 
  chrom=&quot;chr.*?&quot;,
  &quot;:&quot;,
  chromStart=&quot;[0-9,]+&quot;, keep.digits,
  &quot;(?:&quot;,
    &quot;-&quot;,
    chromEnd=&quot;[0-9,]+&quot;, keep.digits,
  &quot;)?&quot;))
#&gt;   chrom chromStart  chromEnd
#&gt; 1 chr10  213054000 213055000
#&gt; 2  chrM     111000        NA
#&gt; 3  &lt;NA&gt;         NA        NA
#&gt; 4  &lt;NA&gt;         NA        NA
#&gt; 5  chr1        110       111
</code></pre>

<p>Note the repetition in the chromStart/End lines &ndash; the same pattern and type conversion function is used for each group. This repetition can be avoided by creating and using a sub-pattern list variable,</p>

<pre><code class="r">pos.pattern &lt;- list(&quot;[0-9,]+&quot;, keep.digits)
namedCapture::str_match_variable(
  subject.vec, 
  chrom=&quot;chr.*?&quot;,
  &quot;:&quot;,
  chromStart=pos.pattern,
  &quot;(?:&quot;,
    &quot;-&quot;,
    chromEnd=pos.pattern,
  &quot;)?&quot;)
#&gt;   chrom chromStart  chromEnd
#&gt; 1 chr10  213054000 213055000
#&gt; 2  chrM     111000        NA
#&gt; 3  &lt;NA&gt;         NA        NA
#&gt; 4  &lt;NA&gt;         NA        NA
#&gt; 5  chr1        110       111
</code></pre>

<p>Finally, the non-capturing group can be replaced by an un-named list:</p>

<pre><code class="r">namedCapture::str_match_variable(
  subject.vec, 
  chrom=&quot;chr.*?&quot;,
  &quot;:&quot;,
  chromStart=pos.pattern,
  list(
    &quot;-&quot;,
    chromEnd=pos.pattern
  ), &quot;?&quot;)
#&gt;   chrom chromStart  chromEnd
#&gt; 1 chr10  213054000 213055000
#&gt; 2  chrM     111000        NA
#&gt; 3  &lt;NA&gt;         NA        NA
#&gt; 4  &lt;NA&gt;         NA        NA
#&gt; 5  chr1        110       111
</code></pre>

<p>In summary, the <code>str_match_variable</code> function takes a variable number of arguments, and allows for a shorter, less repetitive, and thus more user-friendly syntax:</p>

<ul>
<li>The first argument is the subject character vector.</li>
<li>The other arguments specify the pattern, via character strings,
functions, and/or lists.</li>
<li>If a pattern (character/list) is named, we use the argument name in R for the capture
group name in the regex.</li>
<li>Each function is used to convert the text extracted by the previous
named pattern argument. (type conversion can only be used with named R arguments, NOT with explicitly specified named groups in regex strings)</li>
<li>Lists may be used to avoid repetition in the definition of the pattern and type conversion functions.</li>
<li>Each list generates a group in the regex (named list =&gt; named capture group, un-named list =&gt; non-capturing group).</li>
<li>All patterns are pasted together in the order that they appear in
the argument list.</li>
</ul>

<h2>View generated regex</h2>

<p>To see the regular expression pattern string generated by the
<code>namedCapture::*_variable</code> functions, call <code>variable_args_list</code>
with the variable number of arguments that specify the pattern:</p>

<pre><code class="r">(L &lt;- namedCapture::variable_args_list(
  chrom=&quot;chr.*?&quot;,
  &quot;:&quot;,
  chromStart=pos.pattern,
  list(
    &quot;-&quot;,
    chromEnd=pos.pattern
  ), &quot;?&quot;))
#&gt; $fun.list
#&gt; $fun.list$chromStart
#&gt; function(x)as.integer(gsub(&quot;[^0-9]&quot;, &quot;&quot;, x))
#&gt; &lt;bytecode: 0xb63cc78&gt;
#&gt; 
#&gt; $fun.list$chromEnd
#&gt; function(x)as.integer(gsub(&quot;[^0-9]&quot;, &quot;&quot;, x))
#&gt; &lt;bytecode: 0xb63cc78&gt;
#&gt; 
#&gt; 
#&gt; $pattern
#&gt; [1] &quot;(?P&lt;chrom&gt;chr.*?):(?P&lt;chromStart&gt;[0-9,]+)(?:-(?P&lt;chromEnd&gt;[0-9,]+))?&quot;
identical(L$pattern, single.line.pattern)
#&gt; [1] TRUE
</code></pre>

<p>The generated regex is the <code>pattern</code> element of the resulting list
above (which is internally passed to <code>namedCapture::*_named</code>). Note
how the generated regex is identical to the regex we defined above
using a character string literal; the advantage of
<code>namedCapture::*_variable</code> functions is that the regex is much easier
to read/understand/edit.</p>

<h2>Error if any subjects do not match</h2>

<p>Sometimes you want to stop with an error (instead of reporting a row
of NA) when a subject does not match. In that case, use <code>nomatch.error=TRUE</code>:</p>

<pre><code class="r">namedCapture::str_match_variable(
  subject.vec, 
  chrom=&quot;chr.*?&quot;,
  &quot;:&quot;,
  chromStart=pos.pattern,
  list(
    &quot;-&quot;,
    chromEnd=pos.pattern
  ), &quot;?&quot;,
  nomatch.error=TRUE)
#&gt; [1] &quot;this will not match&quot; NA
#&gt; Error in namedCapture::str_match_variable(subject.vec, chrom = &quot;chr.*?&quot;, : subjects printed above did not match regex below
#&gt; (?P&lt;chrom&gt;chr.*?):(?P&lt;chromStart&gt;[0-9,]+)(?:-(?P&lt;chromEnd&gt;[0-9,]+))?
</code></pre>

<h2>Extract all matches from a multi-line text file subject</h2>

<p>The variable argument syntax can also be used with <code>str_match_all_variable</code>, which is for the common case of extracting each match from a multi-line text file. In this section we demonstrate how to use <code>str_match_all_variable</code> to
extract data.frames from a loosely structured text file. </p>

<pre><code class="r">trackDb.txt.gz &lt;- system.file(
  &quot;extdata&quot;, &quot;trackDb.txt.gz&quot;, package=&quot;namedCapture&quot;)
trackDb.vec &lt;- readLines(trackDb.txt.gz)
</code></pre>

<p>Some representative lines from that file are shown below.</p>

<pre><code class="r">cat(trackDb.vec[78:107], sep=&quot;\n&quot;)
#&gt; track peaks_summary
#&gt; type bigBed 5
#&gt; shortLabel _model_peaks_summary
#&gt; longLabel Regions with a peak in at least one sample
#&gt; visibility pack
#&gt; itemRgb off
#&gt; spectrum on
#&gt; bigDataUrl http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/peaks_summary.bigBed
#&gt; 
#&gt; 
#&gt;  track bcell_McGill0091
#&gt;  parent bcell
#&gt;  container multiWig
#&gt;  type bigWig
#&gt;  shortLabel bcell_McGill0091
#&gt;  longLabel bcell | McGill0091
#&gt;  graphType points
#&gt;  aggregate transparentOverlay
#&gt;  showSubtrackColorOnUi on
#&gt;  maxHeightPixels 25:12:8
#&gt;  visibility full
#&gt;  autoScale on
#&gt; 
#&gt;   track bcell_McGill0091Coverage
#&gt;   bigDataUrl http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/samples/bcell/McGill0091/coverage.bigWig
#&gt;   shortLabel bcell_McGill0091Coverage
#&gt;   longLabel bcell | McGill0091 | Coverage
#&gt;   parent bcell_McGill0091
#&gt;   type bigWig
#&gt;   color 141,211,199
</code></pre>

<p>Each block of text begins with &ldquo;track&rdquo; and includes several lines of
data before the block ends with two consecutive newlines. That pattern
is coded below using a regex:</p>

<pre><code class="r">fields.df &lt;- namedCapture::str_match_all_variable(
  trackDb.vec,
  &quot;track &quot;,
  name=&quot;\\S+&quot;,
  fields=&quot;(?:\n[^\n]+)*&quot;,
  &quot;\n&quot;)
</code></pre>

<p>Note that this function assumes that its first argument is a character vector with one element for each line in a file. Therefore the result contains no information about which subject element each match comes from (to get that, use <code>str_match_all_named</code>).
The code above creates a data frame with one row for each track block,
with rownames given by the track line (because of the capture group
named name), and one fields column which is a string with the rest of
the data in that block.</p>

<pre><code class="r">head(fields.df)
#&gt;                        fields                                                                                                      
#&gt; bcell                  &quot;\nsuperTrack on show\nshortLabel bcell\nlongLabel bcell ChIP-seq samples&quot;                                  
#&gt; kidneyCancer           &quot;\nsuperTrack on show\nshortLabel kidneyCancer\nlongLabel kidneyCancer ChIP-seq samples&quot;                    
#&gt; kidney                 &quot;\nsuperTrack on show\nshortLabel kidney\nlongLabel kidney ChIP-seq samples&quot;                                
#&gt; leukemiaCD19CD10BCells &quot;\nsuperTrack on show\nshortLabel leukemiaCD19CD10BCells\nlongLabel leukemiaCD19CD10BCells ChIP-seq samples&quot;
#&gt; monocyte               &quot;\nsuperTrack on show\nshortLabel monocyte\nlongLabel monocyte ChIP-seq samples&quot;                            
#&gt; skeletalMuscleCtrl     &quot;\nsuperTrack on show\nshortLabel skeletalMuscleCtrl\nlongLabel skeletalMuscleCtrl ChIP-seq samples&quot;
</code></pre>

<p>Each block has a variable number of lines/fields. Each line starts
with a field name, followed by a space, followed by the field
value. That regex is coded below:</p>

<pre><code class="r">fields.list &lt;- namedCapture::str_match_all_named(
  fields.df[, &quot;fields&quot;], paste0(
    &quot;\\s+&quot;,
    &quot;(?P&lt;name&gt;.*?)&quot;,
    &quot; &quot;,
    &quot;(?P&lt;value&gt;[^\n]+)&quot;))
</code></pre>

<p>Note that we used
<code>str_match_all_named</code> which outputs a list in order to keep info about
which match came from which subject. The result is a list of data frames. </p>

<pre><code class="r">fields.list[12:14]
#&gt; $peaks_summary
#&gt;            value                                                                  
#&gt; type       &quot;bigBed 5&quot;                                                             
#&gt; shortLabel &quot;_model_peaks_summary&quot;                                                 
#&gt; longLabel  &quot;Regions with a peak in at least one sample&quot;                           
#&gt; visibility &quot;pack&quot;                                                                 
#&gt; itemRgb    &quot;off&quot;                                                                  
#&gt; spectrum   &quot;on&quot;                                                                   
#&gt; bigDataUrl &quot;http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/peaks_summary.bigBed&quot;
#&gt; 
#&gt; $bcell_McGill0091
#&gt;                       value               
#&gt; parent                &quot;bcell&quot;             
#&gt; container             &quot;multiWig&quot;          
#&gt; type                  &quot;bigWig&quot;            
#&gt; shortLabel            &quot;bcell_McGill0091&quot;  
#&gt; longLabel             &quot;bcell | McGill0091&quot;
#&gt; graphType             &quot;points&quot;            
#&gt; aggregate             &quot;transparentOverlay&quot;
#&gt; showSubtrackColorOnUi &quot;on&quot;                
#&gt; maxHeightPixels       &quot;25:12:8&quot;           
#&gt; visibility            &quot;full&quot;              
#&gt; autoScale             &quot;on&quot;                
#&gt; 
#&gt; $bcell_McGill0091Coverage
#&gt;            value                                                                                      
#&gt; bigDataUrl &quot;http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/samples/bcell/McGill0091/coverage.bigWig&quot;
#&gt; shortLabel &quot;bcell_McGill0091Coverage&quot;                                                                 
#&gt; longLabel  &quot;bcell | McGill0091 | Coverage&quot;                                                            
#&gt; parent     &quot;bcell_McGill0091&quot;                                                                         
#&gt; type       &quot;bigWig&quot;                                                                                   
#&gt; color      &quot;141,211,199&quot;
</code></pre>

<p>There is a list element for each block, named by track. Each list
element is a data frame with one row per field defined in that
block (rownames are field names). The names/rownames make it easy
to write R code that selects individual elements by name, e.g.</p>

<pre><code class="r">fields.list$bcell_McGill0091Coverage[&quot;bigDataUrl&quot;,]
#&gt; [1] &quot;http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/samples/bcell/McGill0091/coverage.bigWig&quot;
fields.list$monocyte_McGill0001Peaks[&quot;color&quot;,]
#&gt; [1] &quot;0,0,0&quot;
has.bigDataUrl &lt;- sapply(fields.list, function(m)&quot;bigDataUrl&quot; %in% rownames(m))
bigDataUrl.list &lt;- fields.list[has.bigDataUrl]
length(bigDataUrl.list)
#&gt; [1] 78
length(fields.list)
#&gt; [1] 123
</code></pre>

<p>So there are 78 tracks which define the bigDataUrl field, out of
123 total tracks.</p>

<p>In the example above we extracted all fields from all tracks (using
two regexes, one for the track, one for the field). In the example
below we extract only the bigDataUrl field for each track, and split
sample names into separate columns (using a single regex for the
track). It also demonstrates how to use nested named capture groups
(via named lists which contain named regex strings).</p>

<pre><code class="r">name.pattern &lt;- list(
  cellType=&quot;.*?&quot;,
  &quot;_&quot;,
  sampleName=list(
    &quot;McGill&quot;,
    sampleID=&quot;[0-9]+&quot;, as.integer),
  dataType=&quot;Coverage|Peaks&quot;,
  &quot;|&quot;,
  &quot;[^\n]+&quot;)
match.df &lt;- namedCapture::str_match_all_variable(
  trackDb.vec,
  &quot;track &quot;,
  name=name.pattern,
  &quot;(?:\n[^\n]+)*&quot;,
  &quot;\\s+bigDataUrl &quot;,
  bigDataUrl=&quot;[^\n]+&quot;)
head(match.df)
#&gt;                          cellType sampleName sampleID dataType
#&gt; all_labels                                         NA         
#&gt; problems                                           NA         
#&gt; jointProblems                                      NA         
#&gt; peaks_summary                                      NA         
#&gt; bcell_McGill0091Coverage    bcell McGill0091       91 Coverage
#&gt; bcell_McGill0091Peaks       bcell McGill0091       91    Peaks
#&gt;                                                                                                            bigDataUrl
#&gt; all_labels                                         http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/all_labels.bigBed
#&gt; problems                                             http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/problems.bigBed
#&gt; jointProblems                                   http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/jointProblems.bigBed
#&gt; peaks_summary                                   http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/peaks_summary.bigBed
#&gt; bcell_McGill0091Coverage    http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/samples/bcell/McGill0091/coverage.bigWig
#&gt; bcell_McGill0091Peaks    http://hubs.hpc.mcgill.ca/~thocking/PeakSegFPOP-/samples/bcell/McGill0091/joint_peaks.bigWig
</code></pre>

<p>Exercise for the reader: modify the above regex in order to capture
three additional columns (red, green, blue) from the color field.</p>

<h2>Extract several columns of a data frame</h2>

<p>We also provide <code>namedCapture::df_match_variable</code> which extracts text
from several columns of a data.frame, using a different named capture
regular expression for each column.</p>

<ul>
<li>It requires a data.frame as the first argument.</li>
<li>It takes a variable number of other arguments, all of which must be
named. For each other argument we call <code>str_match_variable</code> on one
column of the input data.frame.</li>
<li>Each argument name specifies a column of the data.frame which will
be used as the subject in <code>str_match_variable</code>.</li>
<li>Each argument value specifies a pattern to be used with
<code>str_match_variable</code>, in list/character/function format as
explained in the previous section.</li>
<li>The return value is a data.frame with the same number of rows as the
input, but with an additional column for each named capture
group. New columns are named using the convention
<code>subjectColumnName.groupName</code>.</li>
<li>This is a &ldquo;tidy&rdquo; function that can be used in a <a href="https://r4ds.had.co.nz/pipes.html">pipe</a>.
This function can greatly simplify the code required to create numeric
data columns from character data columns. For example consider the
following data which was output from the <a href="https://slurm.schedmd.com/sacct.html">sacct</a> program.</li>
</ul>

<pre><code class="r">(sacct.df &lt;- data.frame(
  Elapsed = c(
    &quot;07:04:42&quot;, &quot;07:04:42&quot;, &quot;07:04:49&quot;,
    &quot;00:00:00&quot;, &quot;00:00:00&quot;),
  JobID=c(
    &quot;13937810_25&quot;,
    &quot;13937810_25.batch&quot;,
    &quot;13937810_25.extern&quot;,
    &quot;14022192_[1-3]&quot;,
    &quot;14022204_[4]&quot;),
  stringsAsFactors=FALSE))
#&gt;    Elapsed              JobID
#&gt; 1 07:04:42        13937810_25
#&gt; 2 07:04:42  13937810_25.batch
#&gt; 3 07:04:49 13937810_25.extern
#&gt; 4 00:00:00     14022192_[1-3]
#&gt; 5 00:00:00       14022204_[4]
</code></pre>

<p>Say we want to filter by the total Elapsed time (which is reported as
hours:minutes:seconds), and base job id (which is the number before
the underscore in the JobID column). We could start by converting
those character columns to integers via:</p>

<pre><code class="r">## Define some sub-patterns separately for clarity.
range.pattern &lt;- list(
  &quot;[[]&quot;,
  task1=&quot;[0-9]+&quot;, as.integer,
  &quot;(?:-&quot;,#begin optional end of range.
  taskN=&quot;[0-9]+&quot;, as.integer,
  &quot;)?&quot;, #end is optional.
  &quot;[]]&quot;)
task.pattern &lt;- list(
  &quot;(?:&quot;,#begin alternate
  task=&quot;[0-9]+&quot;, as.integer,
  &quot;|&quot;,#either one task(above) or range(below)
  range.pattern,
  &quot;)&quot;)#end alternate
(task.df &lt;- namedCapture::df_match_variable(
  sacct.df,
  JobID=list(
    job=&quot;[0-9]+&quot;, as.integer,
    &quot;_&quot;,
    task.pattern,
    &quot;(?:[.]&quot;,
    type=&quot;.*&quot;,
    &quot;)?&quot;),
  Elapsed=list(
    hours=&quot;[0-9]+&quot;, as.integer,
    &quot;:&quot;,
    minutes=&quot;[0-9]+&quot;, as.integer,
    &quot;:&quot;,
    seconds=&quot;[0-9]+&quot;, as.integer)))
#&gt;    Elapsed              JobID JobID.job JobID.task JobID.task1 JobID.taskN
#&gt; 1 07:04:42        13937810_25  13937810         25          NA          NA
#&gt; 2 07:04:42  13937810_25.batch  13937810         25          NA          NA
#&gt; 3 07:04:49 13937810_25.extern  13937810         25          NA          NA
#&gt; 4 00:00:00     14022192_[1-3]  14022192         NA           1           3
#&gt; 5 00:00:00       14022204_[4]  14022204         NA           4          NA
#&gt;   JobID.type Elapsed.hours Elapsed.minutes Elapsed.seconds
#&gt; 1                        7               4              42
#&gt; 2      batch             7               4              42
#&gt; 3     extern             7               4              49
#&gt; 4                        0               0               0
#&gt; 5                        0               0               0
</code></pre>

<p>The result is another data frame with an additional column for each
named capture group. Note that this also works with <code>data.table</code>:</p>

<pre><code class="r">library(data.table)
sacct.dt &lt;- data.table(sacct.df)
(task.dt &lt;- namedCapture::df_match_variable(
  sacct.dt,
  JobID=list(
    job=&quot;[0-9]+&quot;, as.integer,
    &quot;_&quot;,
    task.pattern,
    &quot;(?:[.]&quot;,
    type=&quot;.*&quot;,
    &quot;)?&quot;),
  Elapsed=list(
    hours=&quot;[0-9]+&quot;, as.integer,
    &quot;:&quot;,
    minutes=&quot;[0-9]+&quot;, as.integer,
    &quot;:&quot;,
    seconds=&quot;[0-9]+&quot;, as.integer)))
#&gt;     Elapsed              JobID JobID.job JobID.task JobID.task1
#&gt; 1: 07:04:42        13937810_25  13937810         25          NA
#&gt; 2: 07:04:42  13937810_25.batch  13937810         25          NA
#&gt; 3: 07:04:49 13937810_25.extern  13937810         25          NA
#&gt; 4: 00:00:00     14022192_[1-3]  14022192         NA           1
#&gt; 5: 00:00:00       14022204_[4]  14022204         NA           4
#&gt;    JobID.taskN JobID.type Elapsed.hours Elapsed.minutes Elapsed.seconds
#&gt; 1:          NA                        7               4              42
#&gt; 2:          NA      batch             7               4              42
#&gt; 3:          NA     extern             7               4              49
#&gt; 4:           3                        0               0               0
#&gt; 5:          NA                        0               0               0
</code></pre>

</body>

</html>
